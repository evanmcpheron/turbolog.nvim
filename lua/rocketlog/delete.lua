local M = {}

---Statement node types that are safe to delete as a unit.
---RocketLog insertions are usually expression statements, but a few variants are allowed.
local DELETABLE_STATEMENTS = {
	expression_statement = true,
	lexical_declaration = true,
	variable_declaration = true,
}

---Check whether a line is a RocketLog created by this plugin.
---Supports the current [ROCKETLOG] marker and a legacy rocket-only format.
---@param line_text string|nil
---@return boolean
local function is_rocketlog_line(line_text)
	local rocketlog_label = RocketLogs.config.label or "ROCKETLOG"

	if not line_text or line_text == "" then
		return false
	end

	if line_text:find(rocketlog_label, 1, true) then
		return true
	end

	-- Legacy fallback for older logs before the explicit marker was added.
	return line_text:match("^%s*console%.[%a_]+%s*%(`ðŸš€%s*~") ~= nil
end

---Return a byte column on the line to anchor Tree-sitter node lookup.
---@param line_text string
---@return integer
local function marker_col0(line_text)
	local rocketlog_label = RocketLogs.config.label or "ROCKETLOG"

	local marker_col = line_text:find(rocketlog_label, 1, true)
	if marker_col then
		return marker_col - 1
	end

	local rocket_col = line_text:find("ðŸš€", 1, true)
	if rocket_col then
		return rocket_col - 1
	end

	local first_nonblank = line_text:find("%S")
	return (first_nonblank or 1) - 1
end

---Ascend from a node to the nearest statement node.
---@param node TSNode|nil
---@return TSNode|nil
local function nearest_statement_node(node)
	local current = node
	while current do
		if DELETABLE_STATEMENTS[current:type()] then
			return current
		end
		current = current:parent()
	end
	return nil
end

---Delete an inclusive line range and keep the cursor on a sane line.
---@param start_line integer 1-based inclusive
---@param end_line integer 1-based inclusive
local function delete_line_range(start_line, end_line)
	local bufnr = vim.api.nvim_get_current_buf()
	local total_before = vim.api.nvim_buf_line_count(bufnr)

	vim.api.nvim_buf_set_lines(bufnr, start_line - 1, end_line, false, {})

	local total_after = vim.api.nvim_buf_line_count(bufnr)
	local target_line = math.min(start_line, total_after)

	if target_line < 1 then
		-- Keep at least one empty line in the buffer to avoid invalid cursor placement.
		vim.api.nvim_buf_set_lines(bufnr, 0, 0, false, { "" })
		target_line = 1
	end

	local cur = vim.api.nvim_win_get_cursor(0)
	local target_col = cur[2]
	local target_text = vim.fn.getline(target_line)
	if target_col > #target_text then
		target_col = #target_text
	end

	vim.api.nvim_win_set_cursor(0, { target_line, target_col })
	return total_before ~= total_after
end

---Try deleting the full syntax statement containing the RocketLog line.
---@param line_nr integer 1-based line containing a RocketLog marker
---@return boolean, string|nil
local function delete_with_treesitter(line_nr)
	local line_text = vim.fn.getline(line_nr)
	if not is_rocketlog_line(line_text) then
		return false, "not_rocketlog"
	end

	local ok_parser, parser = pcall(vim.treesitter.get_parser, 0)
	if not ok_parser or not parser then
		return false, "parser_unavailable"
	end

	local ok_parse, trees = pcall(parser.parse, parser)
	if not ok_parse or not trees or not trees[1] then
		return false, "parse_failed"
	end

	local root = trees[1]:root()
	if not root then
		return false, "no_root"
	end

	local row0 = line_nr - 1
	local col0 = marker_col0(line_text)
	local ok_node, node = pcall(root.named_descendant_for_range, root, row0, col0, row0, col0)
	if not ok_node or not node then
		return false, "node_not_found"
	end

	local statement = nearest_statement_node(node)
	if not statement then
		return false, "statement_not_found"
	end

	local sr, _, er, ec = statement:range()
	local start_line = sr + 1
	local end_line = er + 1

	-- Tree-sitter end rows can land on the next line with col=0. Normalize to inclusive line range.
	if ec == 0 and end_line > start_line then
		end_line = end_line - 1
	end

	if end_line < start_line then
		end_line = start_line
	end

	-- Final safety check: only delete statements that actually include a RocketLog marker.
	local statement_lines = vim.api.nvim_buf_get_lines(0, start_line - 1, end_line, false)
	local contains_marker = false
	for _, candidate in ipairs(statement_lines) do
		if is_rocketlog_line(candidate) then
			contains_marker = true
			break
		end
	end

	if not contains_marker then
		return false, "marker_not_in_statement"
	end

	delete_line_range(start_line, end_line)
	return true, nil
end

---Fallback delete when Tree-sitter is unavailable.
---For multiline logs generated by this plugin, scan forward to delete the entire console call block.
---@param line_nr integer
---@return boolean, string|nil
local function delete_line_only(line_nr)
	local line_text = vim.fn.getline(line_nr)
	if not is_rocketlog_line(line_text) then
		return false, "not_rocketlog"
	end

	-- One-line RocketLog (most common case).
	if line_text:find("%)%s*;?%s*$") then
		return delete_line_range(line_nr, line_nr), nil
	end

	-- Best-effort multiline fallback for the plugin's generated console call format.
	local last_line = vim.fn.line("$")
	local paren_depth = 0
	local saw_paren = false

	for candidate_line = line_nr, last_line do
		local candidate_text = vim.fn.getline(candidate_line)
		for i = 1, #candidate_text do
			local ch = candidate_text:sub(i, i)
			if ch == "(" then
				paren_depth = paren_depth + 1
				saw_paren = true
			elseif ch == ")" and saw_paren then
				paren_depth = math.max(0, paren_depth - 1)
			end
		end

		if saw_paren and paren_depth == 0 and candidate_text:find("%)%s*;?%s*$") then
			return delete_line_range(line_nr, candidate_line), nil
		end
	end

	-- Last resort: remove just the marker line rather than doing nothing.
	return delete_line_range(line_nr, line_nr), "line_only"
end

---Find the next/previous RocketLog line from the current cursor location.
---@param direction integer 1 searches below, -1 searches above
---@return integer|nil
local function find_marker_line(direction)
	local cur_line = vim.fn.line(".")
	local last_line = vim.fn.line("$")

	if direction > 0 then
		for line_nr = cur_line + 1, last_line do
			if is_rocketlog_line(vim.fn.getline(line_nr)) then
				return line_nr
			end
		end
		return nil
	end

	for line_nr = cur_line - 1, 1, -1 do
		if is_rocketlog_line(vim.fn.getline(line_nr)) then
			return line_nr
		end
	end

	return nil
end

---Delete a single RocketLog above or below the cursor.
---@param direction integer 1 deletes below, -1 deletes above
---@return boolean
local function delete_nearest(direction)
	local target_line = find_marker_line(direction)
	if not target_line then
		local location = direction > 0 and "below" or "above"
		vim.notify("RocketLog: no RocketLog found " .. location .. " the cursor", vim.log.levels.INFO)
		return false
	end

	local deleted, ts_err = delete_with_treesitter(target_line)
	if deleted then
		return true
	end

	-- Fallback keeps behavior functional even if Tree-sitter is unavailable.
	local line_deleted, fallback_err = delete_line_only(target_line)
	if line_deleted and ts_err and ts_err ~= "not_rocketlog" then
		local message = "RocketLog: deleted log using fallback"
		if fallback_err == "line_only" then
			message = message .. " (line-only)"
		end
		vim.notify(message, vim.log.levels.DEBUG)
	end

	return line_deleted
end

---Delete all RocketLogs in the current buffer.
---Uses Tree-sitter deletion first, then falls back to line-based deletion.
---@return integer deleted_count Number of RocketLogs deleted
function M.clear_buffer_logs()
	local original_cursor = vim.api.nvim_win_get_cursor(0)
	local deleted_count = 0
	local line_nr = 1
	local last_line = vim.fn.line("$")

	while line_nr <= last_line do
		local line_text = vim.fn.getline(line_nr)

		if is_rocketlog_line(line_text) then
			-- Prefer Tree-sitter so multiline logs are deleted as full statements.
			local deleted = false

			local ts_deleted = delete_with_treesitter(line_nr)
			if ts_deleted then
				deleted = true
			else
				local fallback_deleted = delete_line_only(line_nr)
				deleted = fallback_deleted and true or false
			end

			if deleted then
				deleted_count = deleted_count + 1
				-- Buffer changed, so refresh the line count.
				last_line = vim.fn.line("$")
			-- Do not increment line_nr here. A new line has shifted into this position.
			else
				-- Safety: avoid infinite loops if a line matches but cannot be deleted.
				line_nr = line_nr + 1
			end
		else
			line_nr = line_nr + 1
		end
	end

	-- Restore cursor to a sensible location after deletions.
	local final_last_line = vim.fn.line("$")
	local target_line = math.min(original_cursor[1], final_last_line)
	if target_line < 1 then
		target_line = 1
	end

	local target_text = vim.fn.getline(target_line)
	local target_col = math.min(original_cursor[2], #target_text)
	vim.api.nvim_win_set_cursor(0, { target_line, target_col })

	if deleted_count == 0 then
		vim.notify("RocketLog: no RocketLogs found in current buffer", vim.log.levels.INFO)
	else
		vim.notify("RocketLog: deleted " .. deleted_count .. " RocketLog(s) in current buffer", vim.log.levels.INFO)
	end

	return deleted_count
end

---Delete the next RocketLog below the cursor.
---@return boolean
function M.delete_next_log()
	return delete_nearest(1)
end

---Delete the nearest RocketLog above the cursor.
---@return boolean
function M.delete_prev_log()
	return delete_nearest(-1)
end

return M
